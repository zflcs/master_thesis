# Outline

核心亮点：

1. 调度机制
   1. 任务队列的同步互斥
   2. 用户态的抢占式调度
2. 中断处理机制（通知机制）
   1. 快速唤醒机制，中断控制器直接处理（仅在必要时发送中断给 CPU）
   2. 设备虚拟化，在 hypervisor 中的应用（可能）

## 引言

### 研究背景

1. 云服务上的微秒级调度，需要专用的调度核、缺少用户态抢占
2. 已有的中断控制器没有将调度与通知机制结合起来
3. 已有的 IPC 机制

### 已有工作

1. RISC-V N 扩展，x86 用户态中断，其他的中断控制器的设计
2. 用户态驱动框架（DPDK）、用户态任务运行时（Tokio）
3. Chisel 硬件描述语言、rocket-chip SoC 生成器

## 设计方案

### 整体架构

### 控制器内部数据结构

1. 资源分配器
2. 任务队列
3. 外部中断槽
4. 软件中断槽
5. 中断处理机制

### 控制器端口分配

1. 全局端口
2. 局部端口

## QEMU 和 rocket-chip 中的实现

1. N 扩展的实现
2. 控制器数据结构的实现
3. 控制器与 CPU 的交互

## 软件适配

1. 软件接口
2. 软硬件协作的任务状态管理
3. 使用方法（跳板页、异步系统调用、IPC 通信等）

## 性能评估

对比实验：在 Linux 上进行

1. 在用户态进行调度，与已有的微秒级调度结果进行对比（对比突出同步互斥开销，用户态抢占式调度，以往的用户态的调度只能是协作式，需要抢占只能通过内核进行），对 tokio 进行修改，对比
2. DPDK 对比增加了用户态的中断处理后的结果，在用户态使用中断控制器与轮询的对比，与已有的用户态的网络协议栈的对比
3. ipc-bench 对比各种类型的 IPC
4. 将 FlexSC 与控制器结合，与原来的 FlexSC 进行对比，展示系统调用的结果
5. 增加时钟设备的虚拟化实验

## 结论

----------------------

1. 解决的问题
   1. 调度，状态维护、事件触发、切换（从综述调研出发）
   2. 中断，中断的响应速度更快，cpu 的开销更小
   3. 不提设备虚拟化

1. 解决的方法
   1. 硬件维护执行流状态（同步互斥的开销，减少 CPU 的参与）
   2. 用硬件实现由中断导致的执行流状态变换（特权级、切换次数）
   3. 统一执行流的抽象（没有线程、协程明确的区分），执行流在哪执行不关注，开题的题目不需要过多的关注，（从完善任务管理、进程管理等系统调用的 API，需要补实验，尝试写出来，控制块，地址空间的解耦，把 JYK 的工作结合起来）

1. 实验
   1. 切换
   2. 维护
   3. 分析切换的延时
   4. 确定在哪个上面来做
   5. 在 AsyncOS 上改 Tokio，再移植到 Linux，
   6. 综合起来的性能（真实应用）

往年论文送审是五一前后（问一下周围同学），中期答辩，问一下其他老师。

### 要解决的问题

- 调度：状态维护、触发时延和切换开销
- 中断：响应时延和CPU开销

### 解决方法

- 用硬件维护执行流状态：避免同步开销、减少CPU参与、
- 用硬件完成中断导致的执行流状态变化：减少切换、减少特权级切换（用户态中断的思路推进）
- 共享调度器：统一执行流的抽象，用任务解耦进程、线程和协程的关系为执行流与地址空间和堆栈的组合方式；统一进程管理的抽象；有代码梳理的工作量；

### 实验指标

- 任务切换：用户态和内核态的进程、线程和协程切换开销分析（切换时延、切换次数、特权级切换次数）；
- 任务维护开销：并发任务数、响应时延、吞吐率
- 真实应用上的综合性能测试：在AsyncOS上做实验，然后在Linux上进行用户库的改进和性能实验；

future 既可以是数据结构，也可以是算法，模糊了 “程序 = 数据结构 + 算法” 的描述

与调度相关的测试：

1. 从本地局部队列取出任务的开销
2. 从其他队列窃取的开销

边缘触发、电平触发

tokio 的对比实验：

- 使用全局队列，与已有的实现进行对比，得出硬件实现全局队列的同步互斥开销
- 使用局部队列，与 tokio 中的任务窃取进行对比，测试任务窃取的开销
- 修改 tokio，增加抢占的部分，测试尾部延迟
