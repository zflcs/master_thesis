# 标题：基于软硬协同的中断响应和任务调度研究

|时间|任务|
|-|-|
| ～ 3月1号（1 天） | 给出确定大纲|
| 3 月 1 号 ～ 3 月 2 号（1 天） | 填充已有素材 |
| 3 月 2 号 ～ 3 月 7 号（5 天） | 完成研究背景以及文献综述部分 |
| 3 月 7 号 ～ 3 月 18 号（11 天） | 完成设计与实现部分 |
| 3 月 18 号 ～ 3 月 23 号（5 天） | 完成评估以及结论部分 |
| 3 月 23 号 ～ 4 月 3 号（12 天） | 检查错误，完善论文，做 PPT，进行报告 |
| 4 月 3 号 ～ 4 月 7 号（5 天） | 检查错误，提交送审稿 |

## 引言

1. 研究背景
   1. 调度机制（强调调度算法中的同步互斥开销，用户态调度缺少抢占机制）
   2. 中断机制（强调中断驱动 I/O，上半段和下半段等）
2. 选题意义
   1. 降低调度的同步互斥开销
   2. 降低中断响应的开销，减少 CPU 开销
   3. 将中断与任务调度、任务唤醒结合，加速 IPC、系统调用
   4. 提供用户态的抢占式调度，满足多种多样的需求
3. 本文结构

## 文献综述

1. 文献综述
   1. 任务模型（从软件硬件相互推动发展的角度来描述任务模型的变迁过程，强调任务模型的职责（OS（特权级、时钟） -> 进程（地址空间） -> 线程（堆栈） -> 协程（与堆栈解绑）））
   2. 调度机制
   3. 中断/轮询机制
   4. 已有异步编程方法（贯穿上述的几种机制，结合任务模型、任务调度、中断、轮询等，最后落脚点在**并发**上）
2. 本章小结

## 基于软硬协同的中断响应和任务调度设计

1. 统一任务模型设计（强调执行流）（“统一任务模型”这个名称需要商榷）
   1. 统一的任务抽象，将进程、线程、协程的关系进行解耦，组成为执行流与地址空间和堆栈的组合方式
   2. 分层复合型任务标识
2. 软硬协同的任务状态模型设计
   1. 描述哪些状态由硬件维护、哪些由软件维护
   2. 描述清楚任务状态之间如何转换
3. 软硬件交互接口设计
   1. 在这里逐步介绍在这个抽象下软件的实现（硬件来完成了软件的工作，完成由于中断导致的任务状态变化，直接唤醒阻塞任务）
4. 本章小结

## 基于软硬协同的中断响应和任务调度实现

1. 系统整体结构（画出一张控制器、CPU、IO 设备、任务的整体示意图）
2. 控制器的实现（描述使用的 SoC、硬件描述语言）
   1. 硬件资源分配器
   2. 任务队列的实现（突出同步互斥、任务窃取、优先级队列等）
   3. 外部中断的处理逻辑
   4. 软件中断的处理逻辑
   5. 发中断的逻辑（中断状态、中断屏蔽等描述）
3. RISC-V CPU 的 N 扩展实现（描述相关的寄存器，以及控制器与 CPU 中断寄存器的连接方式）
4. 软件适配（根据 async_os 进行描述，描述上述概念怎么落实）
   1. 内核和用户态怎么使用硬件调度器（接口的使用、分配）
   2. 任务如何切换（涉及到任务调度、抢占等）
   3. 任务之间如何通过硬件构建通信通道（怎么支持多个发送方和接收方）
5. 本章小结

## 性能评估

1. 增加定性特征分析
2. 测试环境（需要说明 CPU 与内存交互和设备交互都是通过 TL 总线协议进行，因此两者的访问速度是相当的）
3. 微基准测试
   1. 接口开销
   2. ipc-bench，体现通信机制上的优化（中断延时，中断上下文切换开销，中断的上下半段、各个阶段的划分对比，各自的开销，画出图片，可参考已有论文）
   3. tokio 调度器对比实验，体现调度机制上的优化（硬件支持的任务窃取机制对比软件实现的任务窃取算法、同步互斥的优化）
4. 综合测试
   1. 采用 ldh 的实验结果，在 rel4 上构建的测试（画出三幅图、原始通知机制、以及采用两种不同的中断控制器的实现的结构图，体现出特权级切换次数、中断次数、并发任务数、响应延时、吞吐率等性能指标）
   2. （根据时间补充在 async_os、linux 上的测试）
5. 本章小结

## 总结与展望
